<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>Fire: fire Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">Fire </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fire Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00774.html">BasicPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00770.html">ConstantStrainTriangleElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html">DelimitedTextParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00778.html">IdentifiablePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00782.html">IdentifiableTriplet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00810.html">ILocalParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00814.html">INIPropertyParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00818.html">IParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00822.html">IPropertyParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00794.html">IStepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00870.html">IVPSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00862.html">LineQuadratureRule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00826.html">LocalParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00790.html">PoissonCST</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00798.html">ProfileStepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00874.html">State</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00830.html">StringCaster</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00846.html">StringCaster&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00834.html">StringCaster&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00838.html">StringCaster&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00842.html">StringCaster&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00802.html">System</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00866.html">TriangularQuadratureRule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00786.html">TwoDRobinBoundaryCondition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a92dafcc05a788e1065a5792b67f0f70e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#a92dafcc05a788e1065a5792b67f0f70e">TwoDNode</a> = <a class="el" href="a00778.html">IdentifiablePair</a>&lt; double, double, int &gt;</td></tr>
<tr class="separator:a92dafcc05a788e1065a5792b67f0f70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124b14f4255dab47a3f7235a02cc65ee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#a124b14f4255dab47a3f7235a02cc65ee">CSTLocalPoint</a> = <a class="el" href="a00782.html">IdentifiableTriplet</a>&lt; double, double, double, int &gt;</td></tr>
<tr class="separator:a124b14f4255dab47a3f7235a02cc65ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f01d4bb892cf7b2386d0f3a8643d72"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a08f01d4bb892cf7b2386d0f3a8643d72"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#a08f01d4bb892cf7b2386d0f3a8643d72">VectorElement</a> = <a class="el" href="a00774.html">BasicPair</a>&lt; int, T &gt;</td></tr>
<tr class="separator:a08f01d4bb892cf7b2386d0f3a8643d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a12603621e7a1efa59ac5cb79f9d509"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1a12603621e7a1efa59ac5cb79f9d509"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#a1a12603621e7a1efa59ac5cb79f9d509">MatrixElement</a> = <a class="el" href="a00778.html">IdentifiablePair</a>&lt; int, int, T &gt;</td></tr>
<tr class="separator:a1a12603621e7a1efa59ac5cb79f9d509"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abca66b4f2a1543308b663714bd8b4855"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:abca66b4f2a1543308b663714bd8b4855"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00758.html">astrophysics::Reaction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#abca66b4f2a1543308b663714bd8b4855">build</a> (const vector&lt; string &gt; &amp;lines)</td></tr>
<tr class="separator:abca66b4f2a1543308b663714bd8b4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a38ed1e6b331e71a8afc914607c42f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#a9a38ed1e6b331e71a8afc914607c42f4">rowMajorIndex</a> (int i, int j, int rowLength)</td></tr>
<tr class="separator:a9a38ed1e6b331e71a8afc914607c42f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef85c7c5b6740738b8a9d1e7c23aa94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#a3ef85c7c5b6740738b8a9d1e7c23aa94">colMajorIndex</a> (int i, int j, int colLength)</td></tr>
<tr class="separator:a3ef85c7c5b6740738b8a9d1e7c23aa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cef2f47a996b8fa87a343bcc78c5b4c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2cef2f47a996b8fa87a343bcc78c5b4c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#a2cef2f47a996b8fa87a343bcc78c5b4c">rowMajorIndex</a> (<a class="el" href="a00195.html#a1a12603621e7a1efa59ac5cb79f9d509">MatrixElement</a>&lt; T &gt; e, int rowLength)</td></tr>
<tr class="separator:a2cef2f47a996b8fa87a343bcc78c5b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895fa4c103b29fc26eaf95665737980c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a895fa4c103b29fc26eaf95665737980c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#a895fa4c103b29fc26eaf95665737980c">colMajorIndex</a> (<a class="el" href="a00195.html#a1a12603621e7a1efa59ac5cb79f9d509">MatrixElement</a>&lt; T &gt; e, int colLength)</td></tr>
<tr class="separator:a895fa4c103b29fc26eaf95665737980c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7deda7dc809d0d45b8bfed78c8232f9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ac7deda7dc809d0d45b8bfed78c8232f9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#ac7deda7dc809d0d45b8bfed78c8232f9">build</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:ac7deda7dc809d0d45b8bfed78c8232f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b760990569b5c37dc8db51881ae9646"><td class="memTemplParams" colspan="2">template&lt;template&lt; class, typename... &gt; class T, typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a6b760990569b5c37dc8db51881ae9646"><td class="memTemplItemLeft" align="right" valign="top">T&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#a6b760990569b5c37dc8db51881ae9646">build</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a6b760990569b5c37dc8db51881ae9646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09013423ace28591363d86d41d0058b7"><td class="memTemplParams" colspan="2"><a id="a09013423ace28591363d86d41d0058b7"></a>
template&lt;template&lt; class, typename ... &gt; class T, typename K &gt; </td></tr>
<tr class="memitem:a09013423ace28591363d86d41d0058b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00826.html">LocalParser</a>&lt; T&lt; K &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>buildParser</b> (const std::string &amp;source)</td></tr>
<tr class="separator:a09013423ace28591363d86d41d0058b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f0360fae13ec5b8b93251c695e1821"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#ac3f0360fae13ec5b8b93251c695e1821">splitString</a> (const std::string &amp;line, const std::string &amp;delimiter)</td></tr>
<tr class="separator:ac3f0360fae13ec5b8b93251c695e1821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6f0aa2af9238d6a4e0c47c6ad4caa5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#afe6f0aa2af9238d6a4e0c47c6ad4caa5">splitString</a> (const std::string &amp;line)</td></tr>
<tr class="separator:afe6f0aa2af9238d6a4e0c47c6ad4caa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624f274bd6de1d7b829c9883ac3397cd"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a624f274bd6de1d7b829c9883ac3397cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00814.html">INIPropertyParser</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#a624f274bd6de1d7b829c9883ac3397cd">build</a> (const std::string &amp;source)</td></tr>
<tr class="separator:a624f274bd6de1d7b829c9883ac3397cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b47cfd8a5d8711cdc55e1397487b90b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b47cfd8a5d8711cdc55e1397487b90b"><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#a2b47cfd8a5d8711cdc55e1397487b90b">parse</a> (const string &amp;source)</td></tr>
<tr class="separator:a2b47cfd8a5d8711cdc55e1397487b90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad7faa08ea9d4ad30b439b1d1719dd9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:afad7faa08ea9d4ad30b439b1d1719dd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00874.html">State</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#afad7faa08ea9d4ad30b439b1d1719dd9">buildState</a> (Args &amp;&amp;...args, const long &amp;size=0)</td></tr>
<tr class="separator:afad7faa08ea9d4ad30b439b1d1719dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><hr/>
<p> Copyright (c) 2016-, UT-Battelle, LLC All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>Neither the name of fern nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2>Author(s): Jay Jay Billings (jayjaybillings  gmail  com) </h2>
<hr/>
<p> Copyright (c) 2015-, UT-Battelle, LLC All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>Neither the name of fern nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2>Author(s): Jay Jay Billings (jayjaybillings  gmail  com) </h2>
<hr/>
<p> Copyright (c) 2017-, UT-Battelle, LLC All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>Neither the name of fern nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2>Author(s): Jay Jay Billings (jayjaybillings  gmail  com) </h2>
<p>Explicit member function instantiations for the test structure to return the unknowns and derivatives. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a124b14f4255dab47a3f7235a02cc65ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124b14f4255dab47a3f7235a02cc65ee">&#9670;&nbsp;</a></span>CSTLocalPoint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00195.html#a124b14f4255dab47a3f7235a02cc65ee">fire::CSTLocalPoint</a> = typedef <a class="el" href="a00782.html">IdentifiableTriplet</a>&lt;double,double,double,int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure is a collection of the coordinates (L_1, L_2, L_3) in a Constant Strain Triangle Element. It is used internally by the class of the same name, but may be useful elsewhere. </p>

</div>
</div>
<a id="a1a12603621e7a1efa59ac5cb79f9d509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a12603621e7a1efa59ac5cb79f9d509">&#9670;&nbsp;</a></span>MatrixElement</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00195.html#a1a12603621e7a1efa59ac5cb79f9d509">fire::MatrixElement</a> = typedef <a class="el" href="a00778.html">IdentifiablePair</a>&lt;int,int,T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a simple structure that represents an individual element in a matrix. It is templated so that it can be used in an appropriately typed scenario. Its actual implementation is provided by std::tuple through an alias declaration. The indicies i and j are stored in the first and second positions respectively. The "value" of the matrix element is stored in the third position of the tuple. Here is an example that shows getting the value of a matrix element positioned at (1,0): </p><div class="fragment"><div class="line">MatrixElement&lt;double&gt; element{1, 0, 0.5};</div><div class="line"><span class="keywordtype">int</span> i = std::get&lt;0&gt;(element);</div><div class="line"><span class="keywordtype">int</span> j = std::get&lt;1&gt;(element);</div><div class="line"><span class="keywordtype">double</span> value = std::get&lt;2&gt;(element);</div></div><!-- fragment --><p>This structure is not meant to be used for dense matrices or in situations where array serialization will suffice. However, it may be particularly useful to classes that need to work with sparse matrices or do reductions across matrix elements without sticky pointer arithmetic.</p>
<p>The first int is the major index and the second int is the minor index. So in a row-major storage system the first int is the row index and the second is the column index. In a column-major storage system i is the column index and j is the row index. </p>

</div>
</div>
<a id="a92dafcc05a788e1065a5792b67f0f70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92dafcc05a788e1065a5792b67f0f70e">&#9670;&nbsp;</a></span>TwoDNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00195.html#a92dafcc05a788e1065a5792b67f0f70e">fire::TwoDNode</a> = typedef <a class="el" href="a00778.html">IdentifiablePair</a>&lt;double,double,int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following structure is a simple 2D node with "first" and "second" coordinates that can represent (x,y), (r,theta), or any other two-value, 2D coordinate set. The value member can represent a node id or function value at the x,y point.</p>
<p>It can be initialized with default values of (0,0.0,0.0) or set to a specific set of coordinates as follows. </p><div class="fragment"><div class="line"><a class="code" href="a00195.html#a92dafcc05a788e1065a5792b67f0f70e">TwoDNode</a> node1, node2(1,5.0,6.0);</div></div><!-- fragment --> 
</div>
</div>
<a id="a08f01d4bb892cf7b2386d0f3a8643d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f01d4bb892cf7b2386d0f3a8643d72">&#9670;&nbsp;</a></span>VectorElement</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00195.html#a08f01d4bb892cf7b2386d0f3a8643d72">fire::VectorElement</a> = typedef <a class="el" href="a00774.html">BasicPair</a>&lt;int,T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a simple structure that represents an individual element in a vector. It is templated so that it can be used in an appropriately typed scenario. Its actual implementation is provided by std::pair through an alias declaration. The first value of the pair stores the index in the vector and the second value stores the associated value. It works as such </p><div class="fragment"><div class="line">VectorElement&lt;double&gt; vecElem;</div><div class="line">vecElem.first = 1;</div><div class="line">vecElem.second = 867.5309;</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac7deda7dc809d0d45b8bfed78c8232f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7deda7dc809d0d45b8bfed78c8232f9">&#9670;&nbsp;</a></span>build() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T fire::build </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="a00195.html#abca66b4f2a1543308b663714bd8b4855">build&lt;&gt;()</a> template function defines the basic construction mechanism for objects in Fire. It is an implementation of a dynamic builder pattern that does not require a singleton for construction or registration with a singleton to provide such a construction service.</p>
<p>Build function specializations should always be provided for domain classes used in Fire to insure clean construction.</p>
<p>Those concerned about the performance of calling <a class="el" href="a00195.html#abca66b4f2a1543308b663714bd8b4855">build&lt;&gt;()</a> should know that it performs very well because of C++11's move semantics and return value optimizations provided by the compiler. It may perform slowly when used in debug mode with gcc since these optimizations may be disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optional</td><td>list of arguments for classes that do not use nullary/default constructors and have either more than one or a variadic number of arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of class T. </dd></dl>

</div>
</div>
<a id="a6b760990569b5c37dc8db51881ae9646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b760990569b5c37dc8db51881ae9646">&#9670;&nbsp;</a></span>build() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class, typename... &gt; class T, typename K , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&lt;K&gt; fire::build </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An implementation of the build template for containers. This builder will construct a container of type T&lt;K&gt; and optionally pass the arguments Args to the constructor of that container.</p>
<p>Clients that need the same type of functionality for their own container, but with arguments passed to a single class that is wrapped by the container should explicitly specialize <a class="el" href="a00195.html#abca66b4f2a1543308b663714bd8b4855">build&lt;&gt;()</a> on their own. (See <a class="el" href="a00140_source.html">solvers/State.h</a> for an example.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optional</td><td>list of arguments that are passed to the container's constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of the container class T&lt;K&gt;. </dd></dl>

</div>
</div>
<a id="a624f274bd6de1d7b829c9883ac3397cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624f274bd6de1d7b829c9883ac3397cd">&#9670;&nbsp;</a></span>build() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00814.html">INIPropertyParser</a> fire::build </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a builder for constructing INIPropertyParsers from a string. It constructs, initializes, and parses the properties. Property files are expected to be relatively small, so any copying on return is acceptable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>filename that should be parsed for the properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fully initialized property parser. </dd></dl>

</div>
</div>
<a id="abca66b4f2a1543308b663714bd8b4855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca66b4f2a1543308b663714bd8b4855">&#9670;&nbsp;</a></span>build() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00758.html">astrophysics::Reaction</a> fire::build </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a builder for constructing reactions from a vector of strings. This is meant to work with data parsed from the legacy ASCII format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lines</td><td>The input vector with size 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fully initialized Reaction. </dd></dl>

</div>
</div>
<a id="afad7faa08ea9d4ad30b439b1d1719dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad7faa08ea9d4ad30b439b1d1719dd9">&#9670;&nbsp;</a></span>buildState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00874.html">State</a>&lt;T&gt; fire::buildState </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long &amp;&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a builder for building instances of the <a class="el" href="a00874.html">State</a> class.</p>
<p>This builder can be used to initalize a State&lt;T&gt; as follows: </p><div class="fragment"><div class="line">State&lt;MyClass&gt; state = build&lt;T&gt;();</div><div class="line">State&lt;MyClass&gt; state2 = build&lt;T,int&gt;(4); <span class="comment">// Forwards integer value of 4 to</span></div><div class="line"><span class="comment">// the constructor of T.</span></div><div class="line">State&lt;MyClass&gt; state2 = build&lt;T,int&gt;(4,5); <span class="comment">// Forwards both an integer value of</span></div><div class="line"><span class="comment">// 4 to the constructor of T and a size of 5 to constructor of State.</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Optional</td><td>list of arguments that are forwarded to constructor of the domain class T. </td></tr>
    <tr><td class="paramname">The</td><td>default size of the <a class="el" href="a00874.html">State</a> - the total number of elements in the instance of T. This is an optional para </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A State&lt;T&gt; class initialized with the arguments, if provided. </dd></dl>

</div>
</div>
<a id="a3ef85c7c5b6740738b8a9d1e7c23aa94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef85c7c5b6740738b8a9d1e7c23aa94">&#9670;&nbsp;</a></span>colMajorIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fire::colMajorIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operation computes the column-major index of a matrix element based on its indices. This is useful for computing which index in a 1D array would represent this matrix element if the array was ordered in a column-major fashion. It assumes the starting index is 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the i index of the matrix element </td></tr>
    <tr><td class="paramname">j</td><td>the j index of the matrix element </td></tr>
    <tr><td class="paramname">colLength</td><td>the number of elements in a column of the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index in the column-major ordered matrix </dd></dl>

</div>
</div>
<a id="a895fa4c103b29fc26eaf95665737980c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895fa4c103b29fc26eaf95665737980c">&#9670;&nbsp;</a></span>colMajorIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fire::colMajorIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00195.html#a1a12603621e7a1efa59ac5cb79f9d509">MatrixElement</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operation computes the column-major index of a matrix element based on its indices. This is useful for computing which index in a 1D array would represent this matrix element if the array was ordered in a column-major fashion. It assumes the starting index is 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the matrix element </td></tr>
    <tr><td class="paramname">colLength</td><td>the number of elements in a column of the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index in the column-major ordered matrix </dd></dl>

</div>
</div>
<a id="a2b47cfd8a5d8711cdc55e1397487b90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b47cfd8a5d8711cdc55e1397487b90b">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;vector&lt;T&gt; &gt; fire::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="a00195.html#a2b47cfd8a5d8711cdc55e1397487b90b">parse&lt;&gt;()</a> template function defines a basic mechanism for parsing data objects in Fire. This function was added to clean up parsing with LocalParsers in Fire since the code below is common to almost all local parser types. Instead of copying the four line implementation below all over the code base, client code now looks like the following </p><div class="fragment"><div class="line"><span class="keyword">auto</span> data = parse&lt;T&gt;(filename);</div></div><!-- fragment --><p>Those concerned about the performance of calling <a class="el" href="a00195.html#a2b47cfd8a5d8711cdc55e1397487b90b">parse&lt;&gt;()</a> should know that it performs very well because of C++11's move semantics and return value optimizations provided by the compiler. It may perform slowly when used in debug mode with gcc since these optimizations may be disabled.</p>
<dl class="section return"><dt>Returns</dt><dd>an instance of class T created from the default constructor. </dd></dl>

</div>
</div>
<a id="a9a38ed1e6b331e71a8afc914607c42f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a38ed1e6b331e71a8afc914607c42f4">&#9670;&nbsp;</a></span>rowMajorIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fire::rowMajorIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operation computes the row-major index of a matrix element based on its indices. This is useful for computing which index in a 1D array would represent this matrix element if the array was ordered in a row-major fashion. It assumes i is the row index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the i index of the matrix element </td></tr>
    <tr><td class="paramname">j</td><td>the j index of the matrix element </td></tr>
    <tr><td class="paramname">rowLength</td><td>the number of elements in a row of the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index in the row-major ordered matrix </dd></dl>

</div>
</div>
<a id="a2cef2f47a996b8fa87a343bcc78c5b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cef2f47a996b8fa87a343bcc78c5b4c">&#9670;&nbsp;</a></span>rowMajorIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fire::rowMajorIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00195.html#a1a12603621e7a1efa59ac5cb79f9d509">MatrixElement</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operation computes the row-major index of a matrix element based on its indices. This is useful for computing which index in a 1D array would represent this matrix element if the array was ordered in a row-major fashion. It assumes the starting index is 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the matrix element </td></tr>
    <tr><td class="paramname">rowLength</td><td>the number of elements in a row of the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index in the row-major ordered matrix </dd></dl>

</div>
</div>
<a id="ac3f0360fae13ec5b8b93251c695e1821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f0360fae13ec5b8b93251c695e1821">&#9670;&nbsp;</a></span>splitString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; fire::splitString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a utility function used for splitting strings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>strings to be split </td></tr>
    <tr><td class="paramname">a</td><td>delimiter that marks where tokens should be split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with a string for each entry in the original. </dd></dl>

</div>
</div>
<a id="afe6f0aa2af9238d6a4e0c47c6ad4caa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6f0aa2af9238d6a4e0c47c6ad4caa5">&#9670;&nbsp;</a></span>splitString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; fire::splitString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a utility function used for splitting strings. It is a convenience function for calling splitLine(line,delimiter) with delimiter equal to a single whitespace character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>strings to be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with a string for each entry in the original. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
