<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>Fire: fire::State&lt; T &gt; Class Template Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">Fire </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00189.html">fire</a></li><li class="navelem"><a class="el" href="a00860.html">State</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a00857.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fire::State&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00134_source.html">State.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a697d926ef53bfa150fdabb31db269c21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a697d926ef53bfa150fdabb31db269c21">State</a> ()</td></tr>
<tr class="separator:a697d926ef53bfa150fdabb31db269c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fd4082cd305e2054208a0b9aaa6ad4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a40fd4082cd305e2054208a0b9aaa6ad4">State</a> (const long &amp;numElements)</td></tr>
<tr class="separator:a40fd4082cd305e2054208a0b9aaa6ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca4384c9350a172f8e99cd60ae3e8f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a7ca4384c9350a172f8e99cd60ae3e8f8">State</a> (T domainState)</td></tr>
<tr class="separator:a7ca4384c9350a172f8e99cd60ae3e8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d31866ba56d0017805f2065eb3302a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a4d31866ba56d0017805f2065eb3302a3">State</a> (T domainState, const long &amp;numElements)</td></tr>
<tr class="separator:a4d31866ba56d0017805f2065eb3302a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb16dbbaab3549c09da734605f815a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#adfb16dbbaab3549c09da734605f815a3">addMonitor</a> (std::function&lt; void(<a class="el" href="a00860.html">State</a>&lt; T &gt; &amp;)&gt; monitor)</td></tr>
<tr class="separator:adfb16dbbaab3549c09da734605f815a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79792c7af9513986cb97627054c26edf"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a79792c7af9513986cb97627054c26edf">get</a> ()</td></tr>
<tr class="separator:a79792c7af9513986cb97627054c26edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8acc4d5bdd8942de10d34c55680349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a5d8acc4d5bdd8942de10d34c55680349">t</a> (double t)</td></tr>
<tr class="separator:a5d8acc4d5bdd8942de10d34c55680349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425a0236c4edc506b30196d352118104"><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a425a0236c4edc506b30196d352118104">t</a> () const</td></tr>
<tr class="separator:a425a0236c4edc506b30196d352118104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b811d98a73f53fd9b3901a10ec793da"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a3b811d98a73f53fd9b3901a10ec793da">u</a> ()</td></tr>
<tr class="separator:a3b811d98a73f53fd9b3901a10ec793da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6b91c51fe4d53f268a33c77fecff11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a1b6b91c51fe4d53f268a33c77fecff11">u</a> (double *data)</td></tr>
<tr class="separator:a1b6b91c51fe4d53f268a33c77fecff11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8512e68bd6c39042eeede06dc58d390d"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a8512e68bd6c39042eeede06dc58d390d">dudt</a> (const double &amp;<a class="el" href="a00860.html#a5d8acc4d5bdd8942de10d34c55680349">t</a>)</td></tr>
<tr class="separator:a8512e68bd6c39042eeede06dc58d390d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b2d9e2feb153c819e90a4ac7ee8d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a22b2d9e2feb153c819e90a4ac7ee8d72">size</a> (const long &amp;numElements)</td></tr>
<tr class="separator:a22b2d9e2feb153c819e90a4ac7ee8d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f1d7b5ce637db79b96f29bd146842a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a19f1d7b5ce637db79b96f29bd146842a">size</a> () const</td></tr>
<tr class="separator:a19f1d7b5ce637db79b96f29bd146842a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc1fcd953b86552fb9e2b6c15baef6d"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:abfc1fcd953b86552fb9e2b6c15baef6d"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00860.html#abfc1fcd953b86552fb9e2b6c15baef6d">u</a> ()</td></tr>
<tr class="separator:abfc1fcd953b86552fb9e2b6c15baef6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3ffc947a9658d7e7173591460d9424"><td class="memTemplParams" colspan="2"><a id="a2a3ffc947a9658d7e7173591460d9424"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2a3ffc947a9658d7e7173591460d9424"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u</b> (double *uData)</td></tr>
<tr class="separator:a2a3ffc947a9658d7e7173591460d9424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf6b9e3906f1c61bcfbd3df518352f8"><td class="memTemplParams" colspan="2"><a id="aaaf6b9e3906f1c61bcfbd3df518352f8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aaaf6b9e3906f1c61bcfbd3df518352f8"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dudt</b> (const double &amp;<a class="el" href="a00860.html#a5d8acc4d5bdd8942de10d34c55680349">t</a>)</td></tr>
<tr class="separator:aaaf6b9e3906f1c61bcfbd3df518352f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075464a65d420579b91253e4eee1c238"><td class="memTemplParams" colspan="2"><a id="a075464a65d420579b91253e4eee1c238"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a075464a65d420579b91253e4eee1c238"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u</b> ()</td></tr>
<tr class="separator:a075464a65d420579b91253e4eee1c238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70019e1e9e42f93a40b99c79e1e0df8d"><td class="memTemplParams" colspan="2"><a id="a70019e1e9e42f93a40b99c79e1e0df8d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a70019e1e9e42f93a40b99c79e1e0df8d"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dudt</b> (const double &amp;<a class="el" href="a00860.html#a5d8acc4d5bdd8942de10d34c55680349">t</a>)</td></tr>
<tr class="separator:a70019e1e9e42f93a40b99c79e1e0df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075464a65d420579b91253e4eee1c238"><td class="memTemplParams" colspan="2"><a id="a075464a65d420579b91253e4eee1c238"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a075464a65d420579b91253e4eee1c238"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u</b> ()</td></tr>
<tr class="separator:a075464a65d420579b91253e4eee1c238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70019e1e9e42f93a40b99c79e1e0df8d"><td class="memTemplParams" colspan="2"><a id="a70019e1e9e42f93a40b99c79e1e0df8d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a70019e1e9e42f93a40b99c79e1e0df8d"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dudt</b> (const double &amp;<a class="el" href="a00860.html#a5d8acc4d5bdd8942de10d34c55680349">t</a>)</td></tr>
<tr class="separator:a70019e1e9e42f93a40b99c79e1e0df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad271749a2a4f73c11e82ae28141d3b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#ad271749a2a4f73c11e82ae28141d3b65">notifyMonitors</a> ()</td></tr>
<tr class="separator:ad271749a2a4f73c11e82ae28141d3b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac0008054a4c1e589bcbf17b9057daa41"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#ac0008054a4c1e589bcbf17b9057daa41">state</a></td></tr>
<tr class="separator:ac0008054a4c1e589bcbf17b9057daa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4985617940993cea772a7fc977c87237"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a4985617940993cea772a7fc977c87237">tVal</a></td></tr>
<tr class="separator:a4985617940993cea772a7fc977c87237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f8f4ea745ae855ef730896efabf1ae"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a08f8f4ea745ae855ef730896efabf1ae">systemSize</a></td></tr>
<tr class="separator:a08f8f4ea745ae855ef730896efabf1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae89d6e350df763d503d7da862f1f30a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#aae89d6e350df763d503d7da862f1f30a">uArr</a></td></tr>
<tr class="separator:aae89d6e350df763d503d7da862f1f30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9954ba8c1a12555ca1bf67b6a2bf2b3b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#a9954ba8c1a12555ca1bf67b6a2bf2b3b">dudtArr</a></td></tr>
<tr class="separator:a9954ba8c1a12555ca1bf67b6a2bf2b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1571b0a1c82060e525ce6ce2119ae5e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::function&lt; void(<a class="el" href="a00860.html">State</a>&lt; T &gt; &amp;)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00860.html#ae1571b0a1c82060e525ce6ce2119ae5e">monitors</a></td></tr>
<tr class="separator:ae1571b0a1c82060e525ce6ce2119ae5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class fire::State&lt; T &gt;</h3>

<p>This is a container class for user-provided data structures that can be passed to solvers. It is designed such that container operations are handled by default by the template and clients override the <a class="el" href="a00860.html#a3b811d98a73f53fd9b3901a10ec793da">u()</a> and <a class="el" href="a00860.html#a8512e68bd6c39042eeede06dc58d390d">dudt()</a> operations to tailor the behavior for the templated type.</p>
<p>Instances should be constructed using the <a class="el" href="a00189.html#abca66b4f2a1543308b663714bd8b4855">build&lt;&gt;()</a> templates as follows: </p><div class="fragment"><div class="line">State&lt;T&gt; myState = build&lt;T&gt;(); <span class="comment">// If T() takes no arguments</span></div><div class="line">State&lt;T&gt; myState2 = build&lt;T,int&gt;(); <span class="comment">// If T takes one argument</span></div><div class="line">State&lt;T&gt; myState3 = build&lt;T,int, const double &amp;&gt;(); <span class="comment">// If T takes 2 args</span></div><div class="line"><span class="comment">//...etc.</span></div></div><!-- fragment --><p>The variable t, when discussed below, is meant to represent a free parameter on which u and du depend. It commonly represents time, but might might also represent some other parameter. It is not explicitly called "time" to keep the interface clean of any concepts that might limit the scope of the class to only data that is used in time integrations, when in fact it can be used in the solution of any initial value problem.</p>
<p>The layout of the state is, in effect, a matrix with size n_e * n_t, where n_e is the number of unique elements (or unknowns) considered in the system and n_t is the number of values of t at which those values are considered. Thus, in the case where a problem has six unknowns (n_e = 6) and fifty time steps (t = time and n_t = 50), the state class could represent a 6 x 50 matrix with a total of 300 elements. Note that whether or not "the matrix" is stored in column or row major format is not important.</p>
<p>This class is designed to be greedy and narcissistic. In lieu of allowing users to create and store their own instances of T, it creates (add()) those instances and forces users to interact with references retrieved using the getters. Being so greedy makes it possible for this class to efficiently manage memory with lower implementation overhead and no need to rely on clients to correctly initialize data. The original design of this class called for extensive use of smart pointers (using std::share), but there are few computational advantages - if any - compared to simple references. This is because simple references do not incur atomic increment and decrement costs when crossing function boundaries, but smart pointers do. In the author's personal experience, the cost of working with smart pointers can be as much as a factor of two in tight loops with function boundaries. References are, by comparison, free in tight loops. Alternatively, passing a reference to the smart pointer is also free, but it is hardly necessary to share a smart pointer at all if the client does not need to participate in the memory lifecycle of the class, and indeed the practice is not recommended (c.f. - Sutter's 2014 talk) at all in that case.</p>
<p>Three operations are provided for working with "fundamental state
vectors" as arrays of doubles, but casual users are warned that these operations are for those implementing fast solvers based on this class and, in general, casual users should stick to add() and <a class="el" href="a00860.html#a79792c7af9513986cb97627054c26edf">get()</a>.</p>
<p><a class="el" href="a00860.html">State</a> objects can be monitored by registering a functor with the <a class="el" href="a00860.html#adfb16dbbaab3549c09da734605f815a3">addMonitor()</a> operation. The simplest example is to use a Lambda as follows: </p><div class="fragment"><div class="line">   <span class="comment">// Register an observer to write a message when the state changes.</span></div><div class="line"><a class="code" href="a00860.html#ac0008054a4c1e589bcbf17b9057daa41">state</a>.add([](State&lt;ReactionNetwork&gt; &amp; <a class="code" href="a00860.html#ac0008054a4c1e589bcbf17b9057daa41">state</a>) {</div><div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;Lambda Test &quot;</span> &lt;&lt; state.t() &lt;&lt; std::endl;</div><div class="line">   <span class="keywordflow">return</span>;</div><div class="line">});</div></div><!-- fragment --><p> Monitors are only called when <a class="el" href="a00860.html#a1b6b91c51fe4d53f268a33c77fecff11">u(double *)</a> is called. Classes that create explicit specializations of that function should call <a class="el" href="a00860.html#ad271749a2a4f73c11e82ae28141d3b65">notifyMonitors()</a>, a protected notification function, to notify the monitors if they require that functionality. Simply calling the <a class="el" href="a00860.html#ad271749a2a4f73c11e82ae28141d3b65">notifyMonitors()</a> function immediately before return is sufficient.</p>
<p>This class does not yet consider thread safety issues when calling the monitors or updating the state, so be warned.</p>
<p>Common Errors: Declaring T instead of T&amp; - The C++ compiler will not throw an error in the following scenario and will create a copy instead: </p><div class="fragment"><div class="line">T myT1 = state.get(); <span class="comment">// WRONG - Creates a copy of the state!</span></div><div class="line">T &amp; myT2 = state.get(); <span class="comment">// Correct - Uses the state by reference.</span></div><div class="line"><span class="keyword">auto</span> myT3 = state.get(); <span class="comment">// WRONG - Same as the first case.</span></div><div class="line"><span class="keyword">auto</span> &amp; myT4 = state.get(); <span class="comment">// Correct - Same as the second case.</span></div></div><!-- fragment --><p>Road Map:</p><ul>
<li>Right now the auxilliary storage buffers uArr and udtArr are always allocated. It should be possible to enable or disable this.</li>
<li>Should this be thread safe?</li>
<li>Would be interesting to name monitors. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a697d926ef53bfa150fdabb31db269c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697d926ef53bfa150fdabb31db269c21">&#9670;&nbsp;</a></span>State() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::<a class="el" href="a00860.html">State</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor </p>

</div>
</div>
<a id="a40fd4082cd305e2054208a0b9aaa6ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fd4082cd305e2054208a0b9aaa6ad4">&#9670;&nbsp;</a></span>State() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::<a class="el" href="a00860.html">State</a> </td>
          <td>(</td>
          <td class="paramtype">const long &amp;&#160;</td>
          <td class="paramname"><em>numElements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alternative constructor that also sets the system size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>number of unique data elements in the state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ca4384c9350a172f8e99cd60ae3e8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca4384c9350a172f8e99cd60ae3e8f8">&#9670;&nbsp;</a></span>State() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::<a class="el" href="a00860.html">State</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>domainState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alternative default constructor that will accept a pre-configured unique_ptr&lt;T&gt;. In general this constructor should not be called directly by clients. It is used by the <a class="el" href="a00189.html#abca66b4f2a1543308b663714bd8b4855">build&lt;&gt;()</a> builder for State&lt;T&gt; to safely and easily enable two-phase construction where the arguments can be passed to T's constructor without requiring State&lt;T&gt; to know about those arguments.</p>
<p>This is important because requiring State&lt;T&gt; to know about the arguments of T's constructor would require declaring those arguments in all client classes of State&lt;T&gt; that used that version of T, which is an undue burden on the user compared to safely enabling two-phase construction. </p>

</div>
</div>
<a id="a4d31866ba56d0017805f2065eb3302a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d31866ba56d0017805f2065eb3302a3">&#9670;&nbsp;</a></span>State() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::<a class="el" href="a00860.html">State</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>domainState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long &amp;&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alternative constructor that also sets the system size. Analog of <a class="el" href="a00860.html#a40fd4082cd305e2054208a0b9aaa6ad4">State(const long &amp;)</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adfb16dbbaab3549c09da734605f815a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb16dbbaab3549c09da734605f815a3">&#9670;&nbsp;</a></span>addMonitor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::addMonitor </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="a00860.html">State</a>&lt; T &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operation registers a function with the state that will be called when the state changes. Multiple functions may be registered with the <a class="el" href="a00860.html">State</a> and each will be notified when the state is modified. The monitor may be implemented in many ways, but should only take a single State&lt;T&gt;&amp; as an input an return void.</p>
<p>When the monitoring function is called, it will be passed a reference to the instance of the <a class="el" href="a00860.html">State</a> class that changed, not merely to the maintained type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monitor</td><td>the functor that should be notified when the state changes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8512e68bd6c39042eeede06dc58d390d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8512e68bd6c39042eeede06dc58d390d">&#9670;&nbsp;</a></span>dudt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::dudt </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns a simple array of size <a class="el" href="a00860.html#a22b2d9e2feb153c819e90a4ac7ee8d72">State.size()</a> which contains the derivatives of the primary <a class="el" href="a00860.html">State</a> variables with respect to t. Thus it behaves identically to u(t), but provides derivatives instead.</p>
<p>Note that calling this function with the value t will not reset the stored value of t! So calling <a class="el" href="a00860.html#a5d8acc4d5bdd8942de10d34c55680349">t()</a> before and after this function will always return the same value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the value of the free variable, normally time, at which the derivatives of state should be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dudtValues the derivatives at the given value of t </dd></dl>

</div>
</div>
<a id="a79792c7af9513986cb97627054c26edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79792c7af9513986cb97627054c26edf">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operation returns the state at the most recent value of t. Please note the following nuances related to the use of "auto:" </p><div class="fragment"><div class="line">State&lt;T&gt; <a class="code" href="a00860.html#ac0008054a4c1e589bcbf17b9057daa41">state</a>;</div><div class="line">T &amp; myT1 = state.get(); <span class="comment">// Work</span></div><div class="line"><span class="keyword">auto</span> &amp; myT2 = state.get(); <span class="comment">// Works - myT2 has type T &amp;</span></div><div class="line"><span class="keyword">auto</span> myT3 = state.get(); <span class="comment">// Fails - myT3 has type T and is a copy</span></div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>state a reference to the state. </dd></dl>

</div>
</div>
<a id="ad271749a2a4f73c11e82ae28141d3b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad271749a2a4f73c11e82ae28141d3b65">&#9670;&nbsp;</a></span>notifyMonitors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::notifyMonitors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function notifies the monitors. </p>

</div>
</div>
<a id="a22b2d9e2feb153c819e90a4ac7ee8d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b2d9e2feb153c819e90a4ac7ee8d72">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramtype">const long &amp;&#160;</td>
          <td class="paramname"><em>numElements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operation explicitly sets the number of unique data elements in the state. At present this value is constant for all values of t. present in the state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>the number of unique data elements in the state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19f1d7b5ce637db79b96f29bd146842a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f1d7b5ce637db79b96f29bd146842a">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operation returns the number of unique elements in the state. At present this value is constant for all values of t. This is the size of the arrays u and dudt. </p><dl class="section return"><dt>Returns</dt><dd>int the size of the state and the state arrays </dd></dl>

</div>
</div>
<a id="a5d8acc4d5bdd8942de10d34c55680349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8acc4d5bdd8942de10d34c55680349">&#9670;&nbsp;</a></span>t() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::t </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operation updates the value of t. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the new value of t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a425a0236c4edc506b30196d352118104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425a0236c4edc506b30196d352118104">&#9670;&nbsp;</a></span>t() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double&amp; <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operation retrieves the most recent value of t. </p><dl class="section return"><dt>Returns</dt><dd>the most recent value of t </dd></dl>

</div>
</div>
<a id="a3b811d98a73f53fd9b3901a10ec793da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b811d98a73f53fd9b3901a10ec793da">&#9670;&nbsp;</a></span>u() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::u </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns a simple array of size <a class="el" href="a00860.html#a22b2d9e2feb153c819e90a4ac7ee8d72">State.size()</a> which contains the values of the fundamental state vector for this type. This vector is normally used by independent solvers looking to solve systems of equations or analysis routines (regression, etc.) in which case it represents the most recent values of the "unknowns" in the (thus the name "u"). So, for example, when solving the heat equation this could include a vector of temperatures at a given t, but it wouldn't, in general, contain the heat transfer coefficients. The distinction is that the temperature is the unknown in the system and coefficients are already well known.</p>
<p>In general, this function should only be used for coupling to Solvers and other systems by developers and most clients should work with their classes retrieved via the <a class="el" href="a00860.html#a79792c7af9513986cb97627054c26edf">get()</a> operation.</p>
<dl class="section return"><dt>Returns</dt><dd>uValues the state </dd></dl>

</div>
</div>
<a id="a1b6b91c51fe4d53f268a33c77fecff11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6b91c51fe4d53f268a33c77fecff11">&#9670;&nbsp;</a></span>u() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::u </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the values of the unknown quantities. It is the inverse of double * <a class="el" href="a00860.html#a3b811d98a73f53fd9b3901a10ec793da">u()</a> above and is meant to set the values, at the given value of t, for the same fundamental state vector for t_n &gt; t_(n-1). So, for example, this operation could take an input array for t &gt; t_(n-1) that represents the values of temperature just solved for in a coupled thermomechanics system. However, it would not take diffusion coefficient or other quantities.</p>
<p>If the result of the getter <a class="el" href="a00860.html#a3b811d98a73f53fd9b3901a10ec793da">State.u()</a>:double* (see above) is a pointer that is mapped to an array in the stored instance of T, then it is not necessary to call this operation because editing u* directly will update the state. However, in cases where it is desirable to either not map directly to the managed data structure or to use "test values" of u, then this function is a handy convenience function. For example, </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> * <a class="code" href="a00860.html#a3b811d98a73f53fd9b3901a10ec793da">u</a> = state.u()  <span class="comment">// Get the current state</span></div><div class="line"><span class="keywordtype">double</span> <a class="code" href="a00860.html#a425a0236c4edc506b30196d352118104">t</a> = state.t()    <span class="comment">// and t</span></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="a00860.html#a19f1d7b5ce637db79b96f29bd146842a">size</a> = state.size() <span class="comment">// and size</span></div><div class="line"></div><div class="line"><span class="comment">// Make some test updates to u</span></div><div class="line"><span class="keywordtype">double</span> * myU = <span class="keyword">new</span> <span class="keywordtype">double</span>[<a class="code" href="a00860.html#a19f1d7b5ce637db79b96f29bd146842a">size</a>];</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="a00860.html#a19f1d7b5ce637db79b96f29bd146842a">size</a>; i++) {</div><div class="line">    myU[i] = u[i] + delta();</div><div class="line">    ... bunch of other stuff...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Submit the new values</span></div><div class="line">state.u(myU);</div><div class="line"><span class="keywordtype">double</span> * myDudt = state.dudt();</div><div class="line"></div><div class="line">... other stuff ...</div><div class="line"></div><div class="line">delete myU;</div></div><!-- fragment --><p>The default implementation assumes that u is direct pointer to an array in the underlying type T, so implementations may need to override this operation if they do not map directly to the state instance. Furthermore, this operation assumes that the incoming array should be copied instead of referred to directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the values of the unknown state variables to be set. The size of this array is expected to be equal to <a class="el" href="a00860.html#a22b2d9e2feb153c819e90a4ac7ee8d72">State.size()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfc1fcd953b86552fb9e2b6c15baef6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc1fcd953b86552fb9e2b6c15baef6d">&#9670;&nbsp;</a></span>u() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double * <a class="el" href="a00860.html">fire::State</a>&lt; <a class="el" href="a00756.html">ReactionNetwork</a> &gt;::u </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>namespace astrophysics The following operations are explicit instantiations for the <a class="el" href="a00860.html">State</a> state class so that ReactionNetwork can be used in the solver. See <a class="el" href="a00134_source.html">State.h</a> in solvers/ for more information. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9954ba8c1a12555ca1bf67b6a2bf2b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9954ba8c1a12555ca1bf67b6a2bf2b3b">&#9670;&nbsp;</a></span>dudtArr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;double&gt; <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::dudtArr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a utility array that can be used by clients a buffer for holding state derivative values if they cannot be directly mapped to a member on T. </p>

</div>
</div>
<a id="ae1571b0a1c82060e525ce6ce2119ae5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1571b0a1c82060e525ce6ce2119ae5e">&#9670;&nbsp;</a></span>monitors</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::function&lt;void(<a class="el" href="a00860.html">State</a>&lt;T&gt;&amp;)&gt; &gt; <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::monitors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The list of monitors that should be notified when the state changes. </p>

</div>
</div>
<a id="ac0008054a4c1e589bcbf17b9057daa41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0008054a4c1e589bcbf17b9057daa41">&#9670;&nbsp;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The managed instance of the <a class="el" href="a00860.html">State</a> of type T. </p>

</div>
</div>
<a id="a08f8f4ea745ae855ef730896efabf1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f8f4ea745ae855ef730896efabf1ae">&#9670;&nbsp;</a></span>systemSize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::systemSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The system size of the state. </p>

</div>
</div>
<a id="a4985617940993cea772a7fc977c87237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4985617940993cea772a7fc977c87237">&#9670;&nbsp;</a></span>tVal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::tVal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The most recent value of t provided by <a class="el" href="a00860.html#a5d8acc4d5bdd8942de10d34c55680349">State.t()</a>. </p>

</div>
</div>
<a id="aae89d6e350df763d503d7da862f1f30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae89d6e350df763d503d7da862f1f30a">&#9670;&nbsp;</a></span>uArr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;double&gt; <a class="el" href="a00860.html">fire::State</a>&lt; T &gt;::uArr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a utility array that can be used by clients a buffer for holding state values if they cannot be directly mapped to a member on T. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00134_source.html">State.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
